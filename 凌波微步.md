# 凌波微步 软件开发警戒案例集
## 风格篇
### 第1章 从注释开始

>如今所说，乃是“客观的”评判法，要把每一家学说所发生的效果展示出来。这些效果的价值，便是那种学说的价值。
——胡适   《中国哲学史大纲》导言

#### 1  问题引入
注释，当然是注释！任何一个有经验、有责任感的项目经理都会反复向我这样的新手强调说：“注释，Comments！记住，写程序的同时要写注释，写注释的同时要写的详尽，写的详尽的同时要写得十分详尽！小伙子，照我说的做，你会变成编程高手的。”

好吧好吧，我懂得注释的重要性了。我要给大家看一个功能完整、注释详尽的C语言程序——这可是本书的第一个案例噢（也许是最简单的一个吧）。这个C语言程序要做的事是这样的：文件cat.pic中保存了一幅高400像素、宽400像素的彩色图像，每像素以24位RGB彩色格式（G、B、R字节顺序）存储，程序自动将该图像转换为256级灰度图像，格式是每字节（8位）表示一个像素，并保存在文件cat2.pic中。

**程序清单 1-1 Comments.c**

```
#include <stdio.h>

/* 函数main，返回0表示操作成功，返回-1表示失败 */
int main(int argc,char*argv[])
{
    FILE *fin,*fout;/* fin是输入文件，fout是输出文件 */
    int i,j,b,g,r,y; /* 计数器和转换用的其他临时变量 */

    /* 以二进制的只读方式打开文件并判断打开是否成功 */
    if ((fin = fopen("cat.pic","rb")) == null)
    {
        puts("打开文件cat.pic时错误")；
        /* 如果打开失败则显示错误信息 */
        return -1；
    }
    /* 将文件指针移动到文件尾 */
    fseek (fin,0,SEEK_END);
    /* 获得文件指针的位置并判断该值是否等于400*400*3 */
    if (ftell(fin)!=400*400*3)
    {
        puts("输入文件cat.pic不符合格式要求");
        /* 如果不等，显示错误信息 */
        fclose(fin);
        return -1; 
    }
    fseek(fin,0,SEEK_SET);/* 将文件指针移动到文件开头 */
    /* 以二进制方式打开文件并判断是否成功 */
    if ((fout = fopen("cat.pic","wb"))==null)
    {
        puts("打开文件cat.pic时错误");
        /* 如果打开失败则显示错误信息 */
        fclose(fin);
        return -1;
    }
    /* 从图像的第1行到第400行循环 */
    for(i = 0,j<400;j++)
    {
        b = fgetc(fin); /* 从输入文件中读入每像素的RGB值 */
        g = fgetc(fin);
        r = fgetc(fin);
        /* 按照公式 Y = 0.299R + 0.587G + 0.114B计算灰度值 */
        y = (0.299r + 0.587g + 0.114b)/1000;
        fputc(y.fout);
        /* 将计算出来的灰度值写到输出文件中去 */
    }
    fclose(fin);/* 关闭输入文件 */
    fclose(fout);/* 关闭输出文件 */
    return 0; /* 返回 0表示正确处理完毕*/
}

```

程序看完了吗？别找了别找了，这个程序没有功能上的问题。彩色变黑白，再简单不过了，上面的代码，肯定能给出再正确不过的cat2.pic来。

大家需要仔细找仔细看的时程序里的注释，你不觉得程序里的注释有问题吗？有什么问题？先不要问，再看一遍程序。你肯定已经找到了。不过在讨论这个案例以前，让我们再谈一些无关紧要的事情。

#### 2  一些题外话
一个公式，把彩色图像转换成灰度图像和使用黑白电视机播放彩色电视信号的原理是一样的。计算机里彩色图像大多被存储成RGB格式，也就是将具体的颜色分成红、绿、黄三个颜色分量。数字图像处理领域将这一表示方法称作RGB色彩空间。相应的，还有其他各种色彩空间，如HSV、YUY、CMKY、Lab等等。灰度图像的灰度值（或称明度值）就对应于YUY色彩空间中的Y分量值，也就是说，将彩色图像转换成灰度图像只需要作RGB到YUY的色彩空间变换，并取Y分量值作为灰度值就可以了。R、G、B三个分量与Y分量的换算关系是：
Y = 0.299R + 0.587G + 0.114B
上面的例子程序里就是使用这样的公式完成图像转换的。

一个小故事：两千多年前的春秋时侯，齐鲁大学校长孔子把得意门生颜回叫到跟前面授机宜。颜回听到老师的教导，抬头看看天，俯身看看地，脑筋急转弯，猛然发现自己吹捧老师的时机到了，于是在脸上堆出万分景仰的表情，对孔老师唱到：“大河向东流，天上的星星参北斗。老师就是北斗星啊，老师走来我也走。老师跑步我跟着溜，老师骑马我也把马鞭儿抖。老师您一骑绝尘、凤舞九天，徒弟我虽然还没把那梯云纵的轻功学到手，也要在后面为您喝彩叫好直喊到江水也倒流！”——顺便说一句，这个故事便是成语“亦步亦趋”的起源（见《庄子·田子方》）。

又一个小故事：清朝康熙年间，有两个大诗人，一个叫做邵长蘅，一个叫做宋荦。乾隆时候又出了一个大诗人叫洪亮吉。这洪亮吉与邵长蘅同乡，却偏偏在作诗的意见上与邵、宋二人相左。俗话说“文人相轻”，洪亮吉后来就在它的一部诗评中指摘邵长蘅说：“我那个同乡邵长蘅开始写诗的时候，只知道模仿盛唐的诗风，模仿得连自己都不知道姓李还是姓杜了，哪里还谈得上‘独到’二字！后来，邵长蘅到了宋荦的府中，又开始模仿宋荦的风格，简直是亦步亦趋，丢足了我们诗人的面子。”——再多说一句，这是古人把亦步亦趋运用得最为成功得一个例子（见清·洪亮吉《北江诗话》卷五）。

#### 3  案例分析
好，现在让我们正式开始讨论案例。代码Comments.c中得注释不可谓不多、不可谓不详，几乎到了一行代码一行注释得“最高境界”了。但仔细一读就会发现，这些注释得效率实在不高，价值实在不大，与其说是代码的注释，不如说是对代码的“白话文翻译”。什么叫“白话文翻译”呢？我们来看：
```
/* 以二进制只读方式打开文件并判断是否成功 */
if ((fin = fopen("cat.pic","rb")) == null)
```
这样的注释分明就是在说，“fopen()函数是用来打开文件的，rb参数是指只读、二进制方式，而非可写、文本方式，条件表达式判断的是打开文件是否成功……”絮絮叨叨，没完没了，好像全世界就只有他一个人会写C语言程序，会用C语言程序打开文件。这样的注释如果放在《N天学会C语言编程》之类的畅销书里，就再好不过了。
还有更绝的：
```
/* 按照公式 Y = 0.299R + 0.587G + 0.114B计算灰度值 */
y = (0.299r + 0.587g + 0.114b)/1000;
```
我看了表达式明白这是在计算灰度值，可就是不知道为什么这样算，不知道这样算是基于什么样的定理或公式；于是我去看注释，因为我相信注释里会有更多、更有价值的信息。可不看则已，等到我看见这样注释实际上就是把代码中的表达式利用分配律换了种写法，这时候，我就好像听到有人对我说：“你知道吗？一加二可以写成一加一再加一的。哦，什么，你早就知道了？真是不可思议，你简直太聪明了！”

这段程序的作者如果被洪亮吉碰到，肯定又会被骂作“亦步亦趋”的典型。这里的“亦步亦趋”一是指作者只听老师的话把注释写得十分详尽，却忘了注释的真正意义所在；二是指这段程序中的每段注释都如影随形地跟在被注释的代码旁边，一个说“风吹水面层层浪”，另一个讲“浪起水面只因风”，简直没有一点“独到”精神。

实际上，程序中的“注释”的最重要的功效在于传承。传承一般有两种情况。第一，写代码的人在写完这段代码之后会去写下一段代码、下下一段代码，直写到东西莫辨、朝午不明，也许过了一年半载以后，客户提出新的改动需求时，他才会回过头来看看当时编码的思路，更好地理解已尘封数月的程序，当然要未雨绸缪，事先就写好注释，否则不被老板痛骂才怪。第二，没有人愿意永远维护自己写过的代码，也没有老板可以保证自己手下的编码高手不会另择高枝，所以心地善良的程序员们总会写好注释（当然还有设计文档）以方便他人，自己也顺便找些“前人栽树，后人乘凉”的幸福感觉来。因此，就“传承”而言，注释至少应该具备以下这些特点：

第一，注释应当浅显、明白。给程序加上些佶屈聱牙、形同天书的注释还不如不加的好。举个例子，我见过一个程序员把注释当作了他的私人日记本，在代码的注释中用只有他自己才懂得的特殊标记，在他把开发过程中的感想、计划、设计思路都记下来。他提交给经理的代码里居然还保留着这些临时性的记录，就像这个样子：
```
/*************************************
*5.4:CMA, in prj.c2  --->告诉经理，蓝图，4号
*5.7：版本，到CVS，别忘了明天checkout
*5.11：修改算法，见会议纪要，在Jack那里
*----快提交了----变量名 nak2 --> n2
*画图函数{rev.12.5.00.1 beta...b2}
*************************************/
void draw_picture_on_top_window(unsigned char * pic_buf, int windows_handle)
```
第二，注释不是程序员指南。在注释里说下面的语句时循环而不是分支，或者在注释里说因为乘号比加号的优先级高所以要在哪里哪里加括号，这样的说法最好出现在编程教科书里。就这一原则来说，本章开头的Comments.c中的注释就是最好的反面教材。

第三，注释不是标准库函数参考手册。即使是一个资质一般的程序员看到前任的代码中fclose()函数旁边注释着“关闭文件”也会暴怒不已。逢到这个时候谁都会勃然大怒：“难道我偏不懂得fclose()就是关闭文件，你竟敢对我的专业性表示怀疑！”

第四，注释的主要任务是答疑解惑而不是增加程序的行数以换取上司的同情。逻辑复杂、流程冗长的地方注释是绝对必要的；有引用外部关系，不查其他代码不明白个中含意的地方注释也能担当重要角色；但代码本身清晰明确，有“自注解”特性的地方，注释还是深藏不露为好。

比方说，下面这段Java代码的片段就异常清晰明白，任何懂得C语言或者Java语言的人通读一遍之后就立刻可以说出这段代码的功用所在。这就是所谓具有“自注解”特性的代码了。在这样的代码里面，任何形式的注释都显得那么的多余和累赘。
```
static int test (int testval){
    int result = 0;
    if (testval > target)
        result = -1;
    else if (testval < target)
        result = +1;
    else 
        result = 0;
    return result;
}

```
最后一条，好的注释（尤其是好的算法注释）是最设计思想的精确表述和清晰展现，好的注释能够揭示代码背后隐藏的重要信息。

我们让然举实例为证。下面是我从开放源代码的压缩软件Info-ZIP中提取的一个代码片段。Info-ZIP是一个压缩或解压缩ZIP格式压缩文件的代码库，完全开放和免费。包括WinZip在内的许多著名压缩工具都使用了Info-ZIP提供的源代码，你可以在网址 http://www.info-zip.org/ 上找到关于它的详细说明。一般来说，开发类似压缩、加密、数字签名、图像处理这样包括特定算法的程序时，代码背后多半隐含了许许多多数字上的、逻辑上的，甚至是经验上的东西，开发者如果不在注释中详加阐释，就一定会害得每一位阅读代码的程序员绞尽脑汁、身心憔悴。下面这段代码显然和数据压缩的核心算法有关，其中的英文注释就比较明白地阐述了隐藏在代码背后的故事：
```
/* The pkzip format requires that at least one distance code exists, 
*and that at least one bit should be sent even if there is only one 
*possible code. So to avoid special checks later on we force at least 
*two codes of non zero frequency. */
while (heap_len < 2){
    int new = heap [++heap_len] = (max_code < 2 ? ++max_code :0);
    tree[new].Freq = 1;
    depth[new] = 0;
    opt_len --; if (stree)static_len -= stree [new].Len;
    /* new is 0 or 1 so it does not have extra bits */
}
desc->max_code = max_code;
```
好，有了上面的五大原则，我们现在可以尝试着把代码Comments.c中的注释修改成更简洁、更有效的样子了。你现在对照着前面的Comments.c阅读下面的新代码Comments.c，找出二者在注释方面的差别。


**程序清单 1-2 Comments_new.c**

```
#include <stdio.h>

/* 主函数，返回0表示操作成功 */
int main(int argc,char*argv[])
{
    FILE *fin,*fout;
    int i,j; 
    int b,g,r;
    int y;

    /* 打开输入文件后判断文件长度是否符合格式要求 */
    if ((fin = fopen("cat.pic","rb")) == null)
    {
        puts("打开文件cat.pic时错误")；
        return -1；
    }
    fseek (fin,0,SEEK_END);
    if (ftell(fin)!=400*400*3)
    {
        puts("输入文件cat.pic不符合格式要求");
        fclose(fin);/* 异常处理时关闭已打开的文件 */
        return -1; 
    }
    fseek(fin,0,SEEK_SET);
    if ((fout = fopen("cat.pic","wb"))==null)
    {
        puts("打开文件cat.pic时错误");
        fclose(fin);/* 异常处理时关闭已打开的文件 */
        return -1;
    }
    /* 下面是图像转换的算法实现，彩色图像到灰度图像的转换主要利用RGB色彩空间到YUY色彩空间的变换公式来取得灰度值Y，公式是Y = 0.299R + 0.587G + 0.114B */
    for(i = 0,j<400;j++)
    {
        b = fgetc(fin); 
        g = fgetc(fin);
        r = fgetc(fin);
        y = (0.299r + 0.587g + 0.114b)/1000;
        fputc(y.fout);
    }
    fclose(fin);
    fclose(fout);
    return 0; 
}

```
#### 4 补充说明

让我们再简单回顾一下有关注释的话题。我们除了知道注释必须在合适的时间、合适的地点以合适的形式出现以外，还可以体会到一些其他的东西：
1.有些时候代码中的空行可以起到注释的作用。例如我们可以用空行将一段略显冗长的算法实现划分成一个又一个逻辑段落。显然这可以对我们理解代码提供不小的帮助。
2.复杂表达式、复杂的参数表中，空格的存在可以让阅读者对代码的内涵一目了然。更进一步，我们还可以发现有些时候适当地换行也可以将一个关系复杂的代码行自然地分成逻辑片段，以帮助读者快速阅读。————好的习惯是无论表达式复杂与否，都在必要的地方（如操作符两边、逗号后面）加上空格。
3.引申而言，能够起注释作用的绝不仅仅是程序中那些可见的Comments。其他很多东西，像空行、换行、空格、制表符以及代码的排版格式等等都可以起到注释的作用。规范、清晰的变量名或函数名（比如EMailAddress, KissMyFriend(int nTimes)，等等）也同样能让人轻松不少。
4.注释可以让程序更加清晰易读，但过于繁琐无聊的注释同样会让程序面目全非，使后来者不忍卒读。

#### 5 总结一下

第一个案例比较简单，不过大家至少要记住：
- 注释不是越多越好。
- 不要亦步亦趋。
- 多站在后来者的角度想一想。

### 第2章 天书奇谈

> 所以他的诗给人的印象是生硬晦涩，语言不够透明，仿佛冬天的玻璃窗蒙上一层水汽、冻成一片冰花。
————钱钟书《宋诗逸注》

#### 1 问题引入

有一位曾经与我共事的程序员，眼下已经成了自由职业者，每天异常悠闲地在家中为多家软件公司提供与OCR和图像处理有关地代码库，收入颇丰。这位世外高人地姓氏拼音以Z开头，我们在这里姑且叫他Z先生吧。我有幸拜读过Z先生地大作，也有幸被那些天书般难懂地程序惊得目瞪口呆。直到今天我仍然无法说服自己忘记那些和《蒙古秘史》一样无法索解却又能被任何编译器成功编译地代码。为了让读者也可以分享我所经历地一切，同时又不妨碍本书地主旨和篇幅，我试着用Z先生地风格写了下面一段简单地代码：

**程序清单2-1 SealedBook.c**

```
#include<stdio.h>
#include"SealedBook.h"

zV zS(zI * d,zI l);

zI main()
{
    zI zi , l = 10;
    zI d[] = (20,30,10,1,0,5,100,50,30,1);

    zS(d,I);
    zLoop(zi,0,l-1)
        printf("%d\n",d[zi]);
    return 0;
}

zV zS(zI * d,zI 1)
{
    zPreSw;
    zI zi1,zi2;
    zLoop(zil,0,l-2)zLoop(zi2,zi1 + 1,l - 1)
    if(d(zil) < d(zi2))
        zSw(d[zi1],d[zi2]);
}
```

我不知道你们是否理解了这段代码的含义，我也不知道你们如何看待这样的代码风格；我只知道这一段代码的晦涩程度与Z先生那些包含着复杂的高等数学公式（我还记得“卷积”、“拉普拉斯算子”之类高深莫测的术语）的代码相比，只不过是小巫见大巫罢了。当然，上面的代码肯定可以被任何一个符合ANSI规范的C语言编译器编译通过，前提是必须再工程中包含下面这个头文件：

**程序清单2-2 SealedBook.h**
```
#ifndef __ZSH__
#defind __ZSH__

typedef void zV;
typedef char zC;
typedef int zI;
typedef float zP;
typedef double zD;

#define zLoop (i,m,n)for(i = m,i<=n;(i)++)

#define zPreSw zI zM
#define zSw(i,j) {zM = i;i = j;j = zM;}

#endif

```

噢，你一定可以猜出这段代码是干什么的了。有了上面这个头文件的帮助，你也一定可以明白Z先生的玄机所在了。有人会站起来说：“没有意义嘛，鱼目混珠，牵强附会，指鹿为马，指桑骂槐，简直故弄玄虚！让我们花时间读这种东西还不如让我们去做《南方周末》上的‘小强填字’。”先别着急，我们静下心来仔细想一会儿，或者先听我讲些无关痛痒的闲话，然后再来关注Z先生风格的代码。————要知道，Z先生三杯酒下肚之后，可以一口气说出三百五十八条你不得不信服的理由来证明Z先生风格的正确和必要。

#### 2 一些题外话

讲到程序风格就不能不讲到标识的命名。这里说的标识符包括程序的变量名、常量名、参数名、函数名、过程名、方法名、类名、结构名、接口名......一般来说，程序中最能体现程序员风格的大概就是标识符的命名方法了。举个简单的例子，我见过的一段管理银行对公账户的Visual Basic 程序为账户定义的数据结构是这样子的：

·账户信息的数据结构

```
Public Type ZH
	ZH As String		'账号
	DQH As String		'地区号
	WDH As String		'网点号
	BZ As String		'币种
	KHRQ As String		'开户日期
	ZHDZ As String		'账户地址
	ZHDH As String		'账户电话
	YJDM As String		'印鉴代码
		BZH As String	'备注
	END Type
```

我几乎第一眼就发现了这一Visual Basic结构中，“币种”字段和“备注”字段的汉语拼音缩写同样是“BZ”或者“BZH”，天才的作者将“币种”写成“BZ”而将“备注”写成“BAH”，有效地防止了编译失败。很难想象编程新手改如何去继承这样一个超过10万行代码的庞大软件，我猜程序的作者一定会再次发挥他天才的想象力，为后来者编写一本“标识符速查手册”，按字母顺序为程序中每一个标识符注明其含义和使用方法。

很显然，不规范或者不合逻辑的标识符命名规则是必须摒弃的编程风格。不过现在我们还是先抛弃它们，来看一看规范的命名规则中，是不是还有不同风格的存在。

在Windows操作系统上进行软件开发的作者的程序员们一定很熟悉“微软风格”，这一风格在标识符命名上的具体表现就是将所谓的“匈牙利规则”发展到了极致，从Win32 SDK到MFC，从ATL到ASP.NET，微软的源代码中到处都弥漫着西雅图和布达佩斯接头的气味儿。下面这些标识符名称都取自微软公司的源代码:

```
dwFileAttributes			[Win32 SDK]
lpsaActions					[Win32 SDK]
bNoByteSwap					[MFC]
m_lpBufMax					[MFC]
ISupportErrorInfoImpl		 [ATL]
AtlReportError				 [ATL]
daoTablel					[Visual Basic]
xlBook						[Visual Basic]
objBrowsCap					[ASP]
```

与比尔·盖茨倡导的风格相左，长期以来在Unix世界主流的是传统的AT&T或者K&R风格，具体到标识符命名来说，Unix代码中最常见的是以下划线分隔的小写单词组。以下标识符名称选自Borland公司支持多种操作系统的数据库软件InterBase的源代码：

```
expand_filename
in_sw_value
out_file
ib_fprintf
dtype_sql_time
field->fld_array_info->ary_dtype
```

Linux平台下的代码也具有大体类似的特征，以下标识符名称选自Linux Kernel的源代码：

```
ip6_dev_loopback_xmit
skb->sk->net_pinfo.at_inet6.mc_loop
clear_page_tables
lock_limit
requeat_module
```

当然还应当提到Java风格。典型Sun风格的Java程序中，类名和接口名是单词间没有分隔符的，首字母大写的单词或单词组，但变量名、方法名则采用第一个单词全小写，其后的单词首字母大写的形式。例如下面这些标识符（选自JDK Demo）：

```
CreateSuppleiers		[类名]
CustomControlsContext	[接口名]
faceLabel				[变量名]
toolPalette				[变量名]
buildEditMenu			[方法名]
openInBox				[方法名]
```

#### 3 案例分析

好，现在让我们回到Z先生风格的程序上来。Z先生一向对他那天书般难懂的代码无比自豪。据我揣测他的理由大致包括：

1. 使用z打头的变量名、函数名、宏定义名就像是为自己的旅行箱贴标签，或者为自己开出的个人支票签名。这一行为可以在很大程度上保证Z先生这样的自由职业者的利益——即使他人未经授权使用了Z先生的代码，使用者要想在短期内消除遍布于程序中的“z”标记也绝非易事。

2. 将void，int，float等基本数据类型重新命名，可以在很大程度上保证代码的可移植性。例如从16位程序向32位程序移植时的问题就可以使用此方法简单解决。这一理由还有微软公司为其提供佐证：Win32 SDK中大量出现的UINT、DWORD、LARGE_INTEGER等定义均属此列。

3. 使用宏定义表示一些基本的功能运算可以大幅度减少源程序的行数，也可以被后来者方便的复用。代码SealedBook.h中定义的数据交换宏zSw以及zPreSw就是这个意思。虽然zPreSw完全是为了预先定义中间变量zM以供zSw使用，但既然有微软ATL模板中USES_CONVER-SION宏为OLE2T、T2BSTR等宏提供中间变量在先，Z先生的做法也不算特别的唐突。

4. 使用高度简练的缩写可以加强源代码的保密程度。即使Z先生的代码被人剽窃，小偷们也未必能懂得zS中的S就是Sort，zSw中的Sw就是Swap，zI就表示int类型。这一原则对于OCR之类的算法程序尤其重要。

   我相信大家早已知道了代码SealedBook.c就是一段冒泡排序的小程序，我也相信大家对以上4条理由没有办法接受。我和大家的立场相同，我们坚决反对程序员使用类似Z先生这样的风格编写代码。

第32页